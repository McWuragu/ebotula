name: Build & CUnit on master

on:
  pull_request:
    branches: [ master ]  
    types: [ closed ]  
  push:
    branches: [ master ]
  workflow_dispatch: {}            # manueller Start (nur für Nutzer mit Write-Rechten)

permissions:
  contents: write                  # nur nötig, falls wir später Logs in einen Branch schieben

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    env:
      REPO: ${{ github.repository }}
      TOKEN: ${{ secrets.GITHUB_TOKEN }}
      DESTDIR: ${{ github.workspace }}/install

    steps:
      # 🔽 Self-Checkout ohne actions/checkout
      - name: Checkout via git
        run: |
          set -euxo pipefail
          git init .
          git config user.email "actions@users.noreply.github.com"
          git config user.name  "github-actions"
          git remote add origin "https://x-access-token:${TOKEN}@github.com/${REPO}.git"
          # master referenz holen
          git fetch --depth=1 origin master
          git checkout -B master FETCH_HEAD
          git submodule update --init --recursive || true

      - name: Install build deps + gettext + CUnit + gdbm
        run: |
          set -eux
          sudo apt-get update
          sudo apt-get install -y \
            build-essential gcc make \
            autoconf automake libtool pkg-config \
            gettext autopoint \
            libcunit1 libcunit1-dev \
            libgdbm-dev libgdbm-compat-dev
      
      - name: Bootstrap (gettextize + autoreconf)
        run: |
          set -euxo pipefail
          mkdir -p m4
          if grep -q 'AM_GNU_GETTEXT' configure.ac; then
            test -d po || gettextize --force --copy --no-changelog
          fi
          autoreconf --install --force --verbose



      # 🛠️ Configure
      - name: Configure
        run: |
          set -e
          ./configure

      # 🔧 Build
      - name: Build
        run: |
          make -j"$(nproc)"

      # ✅ CUnit-Tests — schlägt fehl, wenn Tests fehlschlagen
      - name: Run CUnit tests
        run: |
          set -e
          # Erstmal "make check" – falls im Autotools-Setup verdrahtet
          if make -q check >/dev/null 2>&1; then
            echo "Running 'make check'..."
            make check
          else
            echo "'make check' nicht definiert – suche Test-Binaries…"
            # Fallback: bekannte Pfade/Dateien probieren
            ran=0
            if [ -x ./testsuit/testsuit ]; then
              echo "Starte ./testsuit/testsuit"
              ./testsuit/testsuit
              ran=1
            fi
            # Findet Dateien mit test_ oder *_tests ausführbar
            mapfile -t bins < <(find . -type f \( -name "test_*" -o -name "*_tests" \) -perm -111 | sort || true)
            if [ "${#bins[@]}" -gt 0 ]; then
              for b in "${bins[@]}"; do
                echo "Starte $b"
                "$b"
                ran=1
              done
            fi
            if [ "$ran" -eq 0 ]; then
              echo "Keine Testbefehle gefunden. Brich ab, weil Tests gefordert sind."
              exit 2
            fi
          fi

      # 🧪 Optional: distcheck (falls du den Check mitprüfen willst; sonst auskommentieren)
      - name: make distcheck
        run: make distcheck

      # 📦 Optional: Installationsprobe (nur zum Verifizieren)
      - name: make install (DESTDIR)
        run: make install DESTDIR="$DESTDIR"

